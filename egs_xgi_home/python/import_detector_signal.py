###############################################################################
#
#   python functions for importing EGS_XGI results/ouputs.
#   copy this file into the directories for python analysis
#   Copyright (C) 2020  ETH ZÃ¼rich
#
#   This file is part of the EGS_XGI - an X-ray grating interferometry
#   extension for EGSnrc.
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU Affero General Public License as published
#   by the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Affero General Public License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
###############################################################################
#
#   Author:     Stefan Tessarini
#
#		Contributors: Werner Volken, Daniel Frei
#
###############################################################################

import numpy as np
import math
import matplotlib.pyplot as plt

# given a file_name without file extension
# extract the detector dimensions form file_name.att
# import and reshape the detector singal from file_name.bin
# return the dimensions of the detector and the detector signal
def import_detector_signal_from_file(file_name):
    attribute_file_name = file_name + '.att'
    attribute_file = open(attribute_file_name, "r")
    line = attribute_file.readline().strip()
    while line:
        split_line = line.partition("=")
        if(split_line[0] == 'Pixels total signal [Nx, Ny] '):
            lines_removed_brackets = split_line[2].strip('[] ')
            values = lines_removed_brackets.partition(',')
            width = int(values[0])
            height = int(values[2])
        line=attribute_file.readline().strip()
    attribute_file.close()
    binary_file_name = file_name + '.bin'
    Detector_Signal = np.reshape(np.fromfile(binary_file_name,float),(height,width))
    return [width, height, Detector_Signal]



def get_detector_dimensions(file_name):
    attribute_file_name = file_name + '.att'
    attribute_file = open(attribute_file_name, "r")
    line = attribute_file.readline().strip()
    print(line)
    while line:
        print(line)
        split_line = line.partition("=")
        if(split_line[0] == 'Dimensions [x,y] '):
            lines_removed_brackets = split_line[2].strip('[] ')
            values = lines_removed_brackets.partition(',')
            FOV_x = float(values[0])
            FOV_y = float(values[2])
            break
        line = attribute_file.readline().strip()
    attribute_file.close()
    return [FOV_x, FOV_y]

def get_number_of_histories(file_name):
    attribute_file_name = file_name + '.att'
    attribute_file = open(attribute_file_name, "r")
    line = attribute_file.readline().strip()
    while line:
        split_line = line.partition("=")
        if(split_line[0] == 'Number of histories '):
            number_of_histories = int(split_line[2])
            break
        line = attribute_file.readline().strip()
    attribute_file.close()
    return number_of_histories

#function computes phase stepping curves for a binary analyzer grating with duty cycle 0.5
# using the following parameters:
#   - nPixelX, nPixelY; number of pixels in x and y directions for rebinning the input signal
#       IMPORTANT: array dimensions are assumed to be an integer multiple of nPixelX and nPixelY
#   - nMask; the width of the mask, i.e. whow many consecutive MC data points are covered by the grating
#       IMPORTANT: the width of the grating sections is assumed to be an integer multiple of the width of a MC data point
#   - nPhaseSteps number of phase steps to perform
#   - Detector_Signal input signal, which can be generated by import_detector_signal_from_file
#! IMPORTANT: Does NOT work with 1 dimensional Detector_Signal input.
def calculate_phase_stepping_curve(nPixelX, nPixelY, nMask, nPhaseSteps, Detector_Signal):
    PhaseSteppingCurve = np.zeros([nPhaseSteps, nPixelY, nPixelX])

    #get dimensions of the detector signal
    width = Detector_Signal.shape[1]
    height = Detector_Signal.shape[0]

    #How many MC data points make a pixel
    nDataPointsPerPixelX = math.floor(width/nPixelX)
    nDataPointsPerPixelY = math.floor(height/nPixelY)

    #Period of G2 in units of MC pixels
    nPeriodG2 = 2 * nMask
    #how many MC-pixels to shift the grating each phase step
    nOffset=math.floor(2*nMask/nPhaseSteps)
    print("nOffset: " + str(nOffset))
    #Calculate the phase stepping curve for each pixel called MacroPixel
    for nPixelCounterX in range(nPixelX):
        for nPixelCounterY in range(nPixelY):
            MacroPixel = np.copy(Detector_Signal[(nPixelCounterY * nDataPointsPerPixelY) : ((nPixelCounterY+1) * nDataPointsPerPixelY) , (nPixelCounterX * nDataPointsPerPixelX) : ((nPixelCounterX+1) * nDataPointsPerPixelX)])
            for nPhaseSetpCounter in range(nPhaseSteps):
                MaskedPixel = np.copy(MacroPixel)
                for nPeriodCounter in range(math.ceil(nDataPointsPerPixelX / nPeriodG2) + 2):
                    #mask pixel from 'nfrom' to 'nto'
                    nfrom = nPeriodCounter * nPeriodG2 - (nDataPointsPerPixelX * nPixelCounterX - nOffset * nPhaseSetpCounter) % nPeriodG2
                    nto = nfrom + nMask
                    if nto > nDataPointsPerPixelX:
                        nto = nDataPointsPerPixelX
                    elif nto <= 0:
                        continue

                    if nfrom <= 0:
                        nfrom = 0

                    if nfrom < nDataPointsPerPixelX:
                        MaskedPixel[:,nfrom:nto] = 0;

                PhaseSteppingCurve[nPhaseSetpCounter, nPixelCounterY, nPixelCounterX] = np.sum(np.sum(MaskedPixel))
    del MacroPixel
    del MaskedPixel
    return PhaseSteppingCurve;



#given a phase stepping curve (e.g. generated by calculate_phase_stepping_curve), get the the visibility map
#v = (Imax-Imin)/(Imax+Imin)
def get_visibility_map(phase_stepping_curve):
    MaxSiganl = np.max(phase_stepping_curve,axis=0)
    MinSignal = np.min(phase_stepping_curve, axis=0)
    return MaxSignal - MinSignal /(MaxSiganl + MinSignal)






#a function to extract the simulation time from the MC output.
#'MC_output_file_name' has to include the file extension.
def get_simulation_time(MC_output_file_name):
    cpu_time = 0.0;
    elapsed_time = 0.0;
    MC_output_file = open(MC_output_file_name, "r")
    for line in MC_output_file:
        line = line.strip();
        split_line = line.partition(":")
        if(split_line[0] == 'CPU time'):
            a = split_line[2].partition('s')
            value = a[0].strip(' ')
            cpu_time = float(value)
        elif(split_line[0] == 'Elapsed time'):
            a = split_line[2].partition('s')
            value = a[0].strip(' ')
            elapsed_time = float(value)
    MC_output_file.close()
    return [cpu_time, elapsed_time]
